import { configure, isTauri } from "webtau";
import { getName, getTauriVersion, getVersion, setAppName, setAppVersion } from "webtau/app";
import { createAssetLoader } from "webtau/assets";
import { createAudioController } from "webtau/audio";
import { createInputController, type TouchPoint } from "webtau/input";
import { createRadarScene, type RadarTheme } from "./game/scene";
import {
  cycleTarget,
  dispatchSupport,
  getMissionView,
  tickMission,
  type MissionView,
} from "./services/backend";
import { publishAlert, subscribeAlerts, type AlertLevel } from "./services/comms";
import {
  loadOperatorProfile,
  recordMissionOutcome,
  saveOperatorProfile,
  type OperatorProfile,
} from "./services/profile";

interface MissionStubConfig {
  callsign: string;
  sector: string;
  objective: string;
  intel: string;
  dispatchProtocol: string[];
}

interface ThemeConfig {
  radar: RadarTheme;
  audio: {
    dispatchSuccessHz: number;
    dispatchFailureHz: number;
    integrityLossHz: number;
    criticalAlertHz: number;
  };
  ui: {
    criticalIntegrityThreshold: number;
  };
}

const FALLBACK_MISSION: MissionStubConfig = {
  callsign: "WATCHTOWER-7",
  sector: "Unknown Sector",
  objective: "Maintain tactical integrity.",
  intel: "No mission config found. Using fallback profile.",
  dispatchProtocol: [],
};

const FALLBACK_THEME: ThemeConfig = {
  radar: {
    background: "#050811",
    grid: "#2a5a7d",
    sweep: "#37c6ff",
    selected: "#ffe680",
  },
  audio: {
    dispatchSuccessHz: 820,
    dispatchFailureHz: 220,
    integrityLossHz: 160,
    criticalAlertHz: 120,
  },
  ui: {
    criticalIntegrityThreshold: 25,
  },
};

function updateHud(view: MissionView): void {
  document.getElementById("mission")!.textContent = view.mission_state;
  document.getElementById("integrity")!.textContent = String(view.integrity);
  document.getElementById("score")!.textContent = String(view.score);
  document.getElementById("tick")!.textContent = String(view.tick);
  document.getElementById("alerts")!.textContent = String(view.alerts);
  document.getElementById("target")!.textContent =
    view.selected_contact_id === null ? "NONE" : `#${view.selected_contact_id}`;
}

function updateProfileHud(profile: OperatorProfile): void {
  document.getElementById("profile")!.textContent =
    `runs ${profile.missionsRun} / best ${profile.bestScore}`;
  document.getElementById("audio-state")!.textContent = profile.muted ? "MUTED" : "ACTIVE";
}

function axisDirection(value: number): number {
  if (value <= -0.45) return -1;
  if (value >= 0.45) return 1;
  return 0;
}

function touchSelectionAxis(touches: TouchPoint[], bounds: DOMRect): number {
  if (touches.length === 0 || bounds.width <= 0) return 0;
  const x = touches[0].x - bounds.left;
  if (x < bounds.width / 3) return -1;
  if (x > (bounds.width * 2) / 3) return 1;
  return 0;
}

function touchDispatchPressed(touches: TouchPoint[], bounds: DOMRect): boolean {
  return touches.some((touch) => {
    const x = touch.x - bounds.left;
    const y = touch.y - bounds.top;
    const inCenter = x >= bounds.width / 3 && x <= (bounds.width * 2) / 3;
    const inBottom = y >= bounds.height * 0.65;
    return inCenter && inBottom;
  });
}

function resolveSelectionDirection(...values: number[]): number {
  for (const value of values) {
    const direction = axisDirection(value);
    if (direction !== 0) return direction;
  }
  return 0;
}

async function main() {
  const modeEl = document.getElementById("mode")!;
  const appMetaEl = document.getElementById("app-meta")!;
  const objectiveEl = document.getElementById("objective")!;
  const alertEl = document.getElementById("alert")!;
  const alertLogEl = document.getElementById("alert-log")!;
  const canvas = document.getElementById("radar") as HTMLCanvasElement;

  if (!isTauri()) {
    modeEl.textContent = "WASM (web)";
    configure({
      loadWasm: async () => {
        // @ts-ignore - generated by wasm-pack into src/wasm at build time
        const wasm = await import("./wasm/battlestation_wasm");
        await wasm.default();
        wasm.init();
        return wasm;
      },
    });
  } else {
    modeEl.textContent = "Tauri IPC (desktop)";
  }

  setAppName("Battlestation Radar");
  setAppVersion("0.3.0");
  const [appName, appVersion, tauriVersion] = await Promise.all([
    getName(),
    getVersion(),
    getTauriVersion(),
  ]);
  appMetaEl.textContent = `${appName} v${appVersion} (${tauriVersion})`;

  const assets = createAssetLoader();
  const [mission, theme] = await Promise.all([
    assets
      .loadJson<MissionStubConfig>("assets/mission-stub.json")
      .catch(() => FALLBACK_MISSION),
    assets.loadJson<ThemeConfig>("assets/battlestation-theme.json").catch(() => FALLBACK_THEME),
  ]);
  objectiveEl.textContent = `${mission.callsign} â€¢ ${mission.objective}`;

  const radar = createRadarScene(canvas, theme.radar);
  const input = createInputController();
  const audio = createAudioController();

  let profile = await loadOperatorProfile();
  audio.setMasterVolume(profile.masterVolume);
  audio.setMuted(profile.muted);
  updateProfileHud(profile);

  const unlockAudio = () => {
    void audio.resume();
  };
  window.addEventListener("keydown", unlockAudio, { once: true });
  window.addEventListener("pointerdown", unlockAudio, { once: true });

  const alertLog: string[] = [];
  const renderAlertLog = () => {
    alertLogEl.textContent = alertLog.join("\n");
  };
  const unlistenAlerts = await subscribeAlerts((alert) => {
    alertEl.textContent = `[${alert.level.toUpperCase()}] ${alert.message}`;
    alertLog.unshift(`T${alert.tick}: ${alert.message}`);
    alertLog.splice(6);
    renderAlertLog();
  });

  await publishAlert({
    level: "info",
    tick: 0,
    message: `${mission.callsign} online in ${mission.sector}.`,
  });

  let view = await getMissionView();
  let lastIntegrity = view.integrity;
  let criticalAlertRaised = false;
  let missionRecorded = false;
  updateHud(view);
  radar.render(view);

  const actions: Array<"left" | "right" | "dispatch"> = [];
  let selectionLatchTime = 0;
  let dispatchLatch = false;
  let muteLatch = false;
  let inFlight = false;

  const step = async () => {
    if (inFlight) return;
    inFlight = true;
    try {
      const now = performance.now();
      const bounds = canvas.getBoundingClientRect();
      const touches = input.touches();
      const selectionDirection = resolveSelectionDirection(
        input.keyAxis(["ArrowLeft", "a", "A"], ["ArrowRight", "d", "D"]),
        input.gamepadAxis(0, { deadzone: 0.35 }),
        touchSelectionAxis(touches, bounds),
      );
      if (selectionDirection !== 0 && now - selectionLatchTime > 220) {
        actions.push(selectionDirection < 0 ? "left" : "right");
        selectionLatchTime = now;
      }

      const dispatchPressed =
        input.isPressed(" ") ||
        input.isPressed("Enter") ||
        input.gamepadAxis(5, { deadzone: 0.4 }) > 0.5 ||
        touchDispatchPressed(touches, bounds);
      if (dispatchPressed && !dispatchLatch) {
        actions.push("dispatch");
      }
      dispatchLatch = dispatchPressed;

      const mutePressed = input.isPressed("m") || input.isPressed("M");
      if (mutePressed && !muteLatch) {
        profile = { ...profile, muted: !profile.muted };
        audio.setMuted(profile.muted);
        await saveOperatorProfile(profile);
        updateProfileHud(profile);
        await publishAlert({
          level: "info",
          tick: view.tick,
          message: profile.muted ? "Audio muted." : "Audio restored.",
        });
      }
      muteLatch = mutePressed;

      while (actions.length > 0) {
        const action = actions.shift();
        if (!action) continue;

        if (action === "left") {
          view = await cycleTarget(-1);
        } else if (action === "right") {
          view = await cycleTarget(1);
        } else {
          const outcome = await dispatchSupport();
          const level: AlertLevel = outcome.success ? "info" : "warning";
          await publishAlert({ level, tick: view.tick, message: outcome.summary });
          if (outcome.success) {
            void audio.playTone(theme.audio.dispatchSuccessHz, 120, {
              type: "triangle",
              gain: 0.15,
            });
          } else {
            void audio.playTone(theme.audio.dispatchFailureHz, 140, {
              type: "sawtooth",
              gain: 0.17,
            });
          }
        }
      }

      view = await tickMission(0.1);
      if (view.integrity < lastIntegrity) {
        await publishAlert({
          level: "warning",
          tick: view.tick,
          message: "Integrity damage detected from unhandled contact pressure.",
        });
        void audio.playTone(theme.audio.integrityLossHz, 180, { type: "square", gain: 0.16 });
      }
      lastIntegrity = view.integrity;

      if (view.integrity <= theme.ui.criticalIntegrityThreshold && !criticalAlertRaised) {
        criticalAlertRaised = true;
        await publishAlert({
          level: "critical",
          tick: view.tick,
          message: "Mission integrity entering critical threshold.",
        });
        void audio.playTone(theme.audio.criticalAlertHz, 260, { type: "square", gain: 0.2 });
      } else if (view.integrity > theme.ui.criticalIntegrityThreshold) {
        criticalAlertRaised = false;
      }

      if (view.mission_state === "FAILED" && !missionRecorded) {
        missionRecorded = true;
        profile = await recordMissionOutcome(profile, view);
        updateProfileHud(profile);
        await publishAlert({
          level: "critical",
          tick: view.tick,
          message: "Mission failed. Reload to run a new operation.",
        });
      }

      updateHud(view);
      radar.render(view);
    } catch (error) {
      alertEl.textContent = `Simulation error: ${String(error)}`;
    } finally {
      inFlight = false;
    }
  };

  // Emit mission protocol guidance once the event pipeline is live.
  for (const line of mission.dispatchProtocol.slice(0, 2)) {
    await publishAlert({ level: "info", tick: view.tick, message: line });
  }

  const timer = setInterval(() => {
    void step();
  }, 100);

  window.addEventListener("beforeunload", () => {
    clearInterval(timer);
    unlistenAlerts();
    input.destroy();
  });
}

main().catch(console.error);
